## 上个分支遗留问题
  --如果对象的属性值是数组，数据劫持的时候会给数组的每个属性设置get和set,会有性能问题
## 原因
  -- 修改数组很少通过索引的方式操作数组，因为arr[999]这样操作内部劫持会消耗性能，一般都是
  通过数组方法:push,shift,unshift...
## 改进
  -- 对于数组的话，不走this.wark(data),而是重写数组的方式
## 注意点
  -- 如果数组中的属性是一个对象，例如vm.kill[0].a = 100，这个时候也要做劫持，所有数组中的每一项也要进行观测
      